# micro:bit Music Player - 設計ドキュメント

## アーキテクチャ概要

```
┌─────────────────────────────────────┐
│         Main Loop (while True)      │
│  ┌───────────────────────────────┐  │
│  │  1. ボタン入力チェック         │  │
│  │  2. 曲データ取得              │  │
│  │  3. 音階変換                  │  │
│  │  4. LED表示                   │  │
│  │  5. 音声再生                  │  │
│  └───────────────────────────────┘  │
└─────────────────────────────────────┘
```

## データ構造

### 1. 曲データベース
```python
songs = {
    "曲名1": [音階データ...],
    "曲名2": [音階データ...],
    # 追加可能
}
```

**設計意図**:
- 辞書を使うことで曲名での管理が容易
- リスト形式で順序を保持
- 新曲追加が簡単

### 2. グローバル状態管理
```python
song_names = list(songs.keys())     # 曲名リスト
current_song_index = 0              # 現在の曲番号
shift = 0                           # キーシフト量（半音単位）
notes = ['C', 'C#', 'D', ...]       # 音階テーブル
```

**設計意図**:
- シンプルな状態管理
- 最小限のメモリ使用
- デバッグが容易

## 主要関数の設計

### shift_note(note, shift)
**目的**: 音階をシフトする

**入力**:
- `note`: 'C4', 'D#5' などの音階文字列
- `shift`: シフト量（正負の整数、半音単位）

**処理フロー**:
```
1. 音名とオクターブを分離
   'C#5' → pitch='C#', octave=5

2. 音階テーブルでインデックス検索
   'C#' → idx=1

3. シフト適用
   idx = idx + shift

4. オクターブ調整
   idx < 0  → オクターブ下げ、idx += 12
   idx >= 12 → オクターブ上げ、idx -= 12

5. 新しい音階文字列を生成
   notes[idx] + str(octave)
```

**出力**: 'D5', 'A3' などの新しい音階

**時間計算量**: O(1) ※ループは最大2回

---

### display_pitch(note)
**目的**: 音の高さをLEDバーで可視化

**入力**: 'C4', 'G5' などの音階文字列

**処理フロー**:
```
1. 音名を抽出
   'C5' → pitch='C'

2. 音階テーブルでインデックス取得
   'C' → idx=0

3. 表示位置計算
   col = idx // 3    # 列（0-4）
   level = (idx % 3) + 1  # 高さ（1-3）

4. LED画像生成
   - 空画像作成
   - 指定列に下からlevel段分点灯

5. 表示
```

**LED配置例**:
```
C → 列0, 高さ1:  █ ▢ ▢ ▢ ▢
C# → 列0, 高さ2: █ ▢ ▢ ▢ ▢
D → 列0, 高さ3:  █ ▢ ▢ ▢ ▢
D# → 列1, 高さ1: ▢ █ ▢ ▢ ▢
E → 列1, 高さ2:  ▢ █ ▢ ▢ ▢
...
```

**時間計算量**: O(1)

---

### next_song() / prev_song()
**目的**: 曲を切り替える

**処理フロー**:
```
1. インデックスを更新（循環）
   next: (index + 1) % 曲数
   prev: (index - 1) % 曲数

2. キーをリセット
   shift = 0

3. 曲名を表示
   display.scroll(曲名)
```

**副作用**:
- `current_song_index`を変更
- `shift`をリセット
- LED表示を更新

---

## ボタン入力処理の設計

### 入力判定フロー
```
ボタン押下検出
    ↓
  800ms待機
    ↓
まだ押されている？
    ├─ YES → 長押し処理
    └─ NO  → 短押し処理
```

### 入力マトリクス
```
┌─────────┬──────────────┬──────────────┐
│ ボタン  │   短押し     │   長押し     │
├─────────┼──────────────┼──────────────┤
│   A     │ キー-1       │ 前の曲       │
│   B     │ キー+1       │ 次の曲       │
│  A+B    │ キーリセット │ キーリセット │
└─────────┴──────────────┴──────────────┘
```

### 同時押し判定
```python
if button_a.is_pressed() and button_b.is_pressed():
    # 優先度最高：キーリセット
    shift = 0
elif button_a.is_pressed():
    # A単独処理
elif button_b.is_pressed():
    # B単独処理
```

**設計意図**:
- 同時押しを最優先で判定（排他制御）
- デバウンス処理（800ms待機）
- 直感的な操作マッピング

---

## メインループの設計

### 処理順序
```
1. 起動メッセージ表示
   display.scroll("Ready")

2. 無限ループ開始
   while True:

3. ボタン入力処理
   - 同時押し → キーリセット
   - A長押し → 前の曲
   - A短押し → キー-1
   - B長押し → 次の曲
   - B短押し → キー+1

4. 曲データループ
   for note_data in current_song:
     a. データパース
        'C5:4' → note='C5', length='4'

     b. 音階変換
        shifted_note = shift_note(note, shift)

     c. LED表示
        display_pitch(note)

     d. 音声再生
        music.play(shifted_note:length)

     e. 割り込みチェック
        if ボタン押下:
          break  # 曲ループ脱出

5. 曲間待機
   sleep(500)  # 0.5秒

6. ループ継続（2に戻る）
```

### 応答性の確保
- 曲の各音ごとにボタンチェック
- 即座に曲ループから脱出可能
- 待ち時間を最小化（500ms）

---

## 音階システムの設計

### 12平均律の実装
```python
notes = ['C', 'C#', 'D', 'D#', 'E', 'F',
         'F#', 'G', 'G#', 'A', 'A#', 'B']
```

**特性**:
- 12音を1オクターブとして定義
- 半音（semitone）が基本単位
- 循環構造（12でモジュロ演算）

### オクターブ管理
```
オクターブ3: C3, C#3, ..., B3
オクターブ4: C4, C#4, ..., B4
オクターブ5: C5, C#5, ..., B5
...
```

**境界処理**:
```python
# 下方向オーバーフロー
if idx < 0:
    octave -= 1
    idx += 12

# 上方向オーバーフロー
if idx >= 12:
    octave += 1
    idx -= 12
```

---

## エラー処理と堅牢性

### 想定エラーケース

1. **音階データの不正**
   - 対策: 事前にデータを検証（開発時）
   - 現在: ハードコードされた信頼できるデータ

2. **オクターブ範囲外**
   - 対策: micro:bitの再生可能範囲を考慮
   - 範囲: オクターブ3～8程度

3. **メモリ不足**
   - 対策: 曲データを最小限に
   - モニタリング: 必要に応じて曲数を調整

### デバッグサポート
```python
# キー変更時に現在値を表示
display.scroll("Key: " + str(shift))

# 曲切り替え時に曲名を表示
display.scroll(song_names[current_song_index])
```

---

## パフォーマンス考慮事項

### メモリ使用量
```
songs辞書: 約200-300バイト（2曲）
グローバル変数: 約100バイト
関数コード: 約500バイト
合計: 約1KB以下
```

### CPU負荷
- 音階変換: O(1)
- LED表示: O(1)
- ボタンチェック: O(1)
- 全体: リアルタイム処理に十分

### 応答時間
- ボタン反応: 最大800ms（デバウンス）
- 曲切り替え: 即座（次の音から）
- LED更新: 即座

---

## 拡張設計

### 追加機能の実装イメージ

#### 1. テンポ調整
```python
tempo = 1.0  # グローバル変数

# 再生部分
duration = int(length) * 250 * tempo
music.play(note, duration)

# ボタン操作追加（例：A+B長押し）
```

#### 2. 再生モード切り替え
```python
play_mode = 'loop'  # 'loop' or 'once'

# メインループ
if play_mode == 'once':
    for note in song:
        # 再生
    break  # 1回だけ
```

#### 3. オクターブ単位のシフト
```python
octave_shift = 0

# shift_note関数内
octave += octave_shift
```

#### 4. LED演出強化
```python
def display_pitch_advanced(note):
    # オクターブを5段階で表現
    octave = int(note[-1])
    height = octave - 3  # オクターブ3を基準
    # より豊かな表現
```

---

## コーディング規約

### 命名規則
- 関数: `snake_case`
- 変数: `snake_case`
- 定数: 実質的に`UPPER_CASE`（notesなど）

### コメント
- 関数の目的をdocstringで明記
- 複雑な処理には行内コメント
- セクション区切りに`#`コメント

### 構造
1. インポート
2. データ定義
3. グローバル変数
4. 関数定義
5. メインループ

---

## テスト戦略

### 手動テスト項目

#### 基本機能
- [ ] 起動時に"Ready"表示
- [ ] 曲が自動再生される
- [ ] LED表示が音に連動

#### ボタン操作
- [ ] A短押し → キー下がる
- [ ] B短押し → キー上がる
- [ ] A長押し → 前の曲
- [ ] B長押し → 次の曲
- [ ] A+B → キーリセット

#### エッジケース
- [ ] キーを+12/-12シフト（1オクターブ）
- [ ] 曲の最初/最後でのナビゲーション
- [ ] 演奏中のボタン操作

#### 音質
- [ ] 音階が正確
- [ ] テンポが適切
- [ ] 音の長さが正確

---

## 依存関係

### MicroPython モジュール
```python
from microbit import *  # display, button_a, button_b, sleep
import music           # music.play, music.NOTES（未使用）
```

### ハードウェア要件
- micro:bit v1.x または v2.x
- スピーカー（内蔵または外部）
- 電源（USB/バッテリー）

---

## バージョニング

### v1.0（現在）
- 基本的な音楽再生
- 2曲対応
- キー変更機能
- LED表示

### v1.1（予定）
- LED演出強化
- 追加楽曲（3-4曲）
- バグフィックス

### v2.0（将来）
- テンポ調整
- 再生モード切り替え
- より豊富な曲ライブラリ
